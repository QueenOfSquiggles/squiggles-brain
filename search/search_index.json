{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Squiggles Brain # A wildly mismanaged knowledge base Welcome and enjoy! I'm still getting things set up initially and like 99% of this is gonna be garbage at first!","title":"Squiggles Brain"},{"location":"#squiggles-brain","text":"A wildly mismanaged knowledge base Welcome and enjoy! I'm still getting things set up initially and like 99% of this is gonna be garbage at first!","title":"Squiggles Brain"},{"location":"about/","text":"Hello there! # This is Queen Of Squiggles's Knowledge Base Wiki! The primary goal of this wiki is to document things I've learned that might be useful to be in a searchable wiki on the web. If you find this wiki useful, that's awesome! If you wanna contribute, check out the repo!","title":"Hello there!"},{"location":"about/#hello-there","text":"This is Queen Of Squiggles's Knowledge Base Wiki! The primary goal of this wiki is to document things I've learned that might be useful to be in a searchable wiki on the web. If you find this wiki useful, that's awesome! If you wanna contribute, check out the repo!","title":"Hello there!"},{"location":"godot/","text":"Godot Knowledge Base # This category is for any knowledge base articles related to the free and open source game engine, Godot For articles specific to the godot-rust GDExtension tool, refer to Godot Rust","title":"Godot Knowledge Base"},{"location":"godot/#godot-knowledge-base","text":"This category is for any knowledge base articles related to the free and open source game engine, Godot For articles specific to the godot-rust GDExtension tool, refer to Godot Rust","title":"Godot Knowledge Base"},{"location":"godot/godot-rust/","text":"Godot Rust Knowledge Base #","title":"Godot Rust Knowledge Base"},{"location":"godot/godot-rust/#godot-rust-knowledge-base","text":"","title":"Godot Rust Knowledge Base"},{"location":"godot/godot-rust/accessing-editor-interface/","text":"Accessing the Editor Interface # If done incorrectly, this will lead to a segmentation fault with no way to debug without more advanced debugging tools. What is crucial is to ensure your EditorPlugin class is the only class using EditorInterface and that it is configured for Godot-Rust to recognize it as an editor plugin! Full Example # #[derive(GodotClass)] #[class(tool, editor_plugin, base=EditorPlugin)] struct MyEditorPlugin { #[base] base: Base<EditorPlugin>, } #[godot_api] impl IEditorPlugin for MyEditorPlugin { fn enter_tree(&mut self) { let Some(editor) = self.base.get_editor_interface() else { return; }; // then we can use \"editor\" to mess with the editor interface } fn exit_tree(&mut self) {} } Crucially, the editor_plugin part of the class definition is what determines to godot-rust that this class is editor-only. This will prevent the errors where EditorInterface is not available. Functionality # This procudure creates essentially a plugin like you could create with GDScript. All of that same functionality is exposed through self.base . However, given that this is compiled at a lower level, you can also hook into other engine features that are less accesible to GDScript. Additionally, this method does not allow disabling the plugin because the entire GDExtension is either successfully loaded or it isn't!","title":"Accessing the Editor Interface"},{"location":"godot/godot-rust/accessing-editor-interface/#accessing-the-editor-interface","text":"If done incorrectly, this will lead to a segmentation fault with no way to debug without more advanced debugging tools. What is crucial is to ensure your EditorPlugin class is the only class using EditorInterface and that it is configured for Godot-Rust to recognize it as an editor plugin!","title":"Accessing the Editor Interface"},{"location":"godot/godot-rust/accessing-editor-interface/#full-example","text":"#[derive(GodotClass)] #[class(tool, editor_plugin, base=EditorPlugin)] struct MyEditorPlugin { #[base] base: Base<EditorPlugin>, } #[godot_api] impl IEditorPlugin for MyEditorPlugin { fn enter_tree(&mut self) { let Some(editor) = self.base.get_editor_interface() else { return; }; // then we can use \"editor\" to mess with the editor interface } fn exit_tree(&mut self) {} } Crucially, the editor_plugin part of the class definition is what determines to godot-rust that this class is editor-only. This will prevent the errors where EditorInterface is not available.","title":"Full Example"},{"location":"godot/godot-rust/accessing-editor-interface/#functionality","text":"This procudure creates essentially a plugin like you could create with GDScript. All of that same functionality is exposed through self.base . However, given that this is compiled at a lower level, you can also hook into other engine features that are less accesible to GDScript. Additionally, this method does not allow disabling the plugin because the entire GDExtension is either successfully loaded or it isn't!","title":"Functionality"}]}